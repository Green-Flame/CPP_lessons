0. Static имеет следующие способы использования:
1) Использование static внутри функции означает, что после того, как переменная была инициализирована, она остается в памяти до конца программы. Например, можно использовать статическую переменную для записи количества раз, когда функция была вызвана, просто добавив строки  static int count = 0; и count++; в функцию. Так как count является статической переменной, строка static int count = 0; будет выполняться только один раз. 
2) Использование static перед глобальной переменной внутри файла, составляющего многофайловую программу, указывает, что исходный код в других файлах, которые являются частью проекта, не может получить доступ к переменной. Только код внутри того же файла может увидеть переменную (её область видимости ограничена файлом).
3) Также static используется внутри определения класса.
Поля класса, объявленные как static, будут иметь то же значение для всех экземпляров данного класса и даже не обязательно создавать экземпляр этого класса. 
Важно отметить, что хорошим тоном при использовании статических переменных класса является использование class_name::х;, а не object_of_class.x;.
Также можно создавать статические методы класса. static методы класса могут выполняться, даже если объект класса не существует. Обращаться к ним следует как class_name::static_function();.

1. Наследование классов позволяет создавать производные классы (классы наследники), взяв за основу все методы и элементы базового класса (класса родителя). Объекты производного класса  свободно могут использовать всё, что создано в базовом классе. При этом в производный класс можно дописать необходимый код для усовершенствования программы: добавить новые элементы, методы и т.д.. Базовый класс останется нетронутым. Таким образом, наследование позволяет избежать дублирования лишнего кода при написании классов.

2. При public наследовании поля public базового класса остаются public для производных. Поле protected базового класса доступно только в методах класса наследника (и наследниках наследника). Поле private недоступно для класса наследника.

3. В С++ указатель (или ссылка) на базовый класс может указывать на объект производного класса, полученного из этого базового класса. Предположим, например, что имеется базовый класс Base_class и его производный класс Derived_class. В С++ любой указатель типа Base_class* может также указы­вать на объект типа Derived_class. Например, если имеются следующие объявления переменных:

Base_class *р; // указатель на объект типа Base_class
Base_class B_ob; // объект типа Base_class
Derived_class D_ob; // объект типа Derived_class

то указателю p можно присвоить следующие значения:

р = &В_оb; // р указывает на объект типа Base_class
р = &D_ob; // р указывает на объект типа Derived_class, являющийся объектом, порожденным от Base_class 

Используя указатель р, можно получить доступ ко всем членам D_ob, которые наследованы от B_ob. Однако специфические члены D_ob не могут быть получены с использованием указателя р (по крайней мере до тех пор, пока не будет осуществлено приведение типов). Это является след­ствием того, что указатель «знает» только о членах базового типа и не знает ничего о специфи­ческих членах производных типов.

4. Виртуальная функция — это функция, объявленная с ключевым словом virtual в базовом классе и переопределенная в одном или в нескольких производных классах. При вызове объекта производ­ного класса с помощью указателя или ссылки на него С++ определяет во время исполнения про­граммы, какую функцию вызвать, основываясь на типе объекта. Для разных объектов вызываются разные версии одной и той же виртуальной функции. Класс, содержащий одну или более вир­туальных функций, называется полиморфным классом (polymorphic class).
Виртуальная функция объявляется в базовом классе с использованием ключевого слова virtual. Когда же она переопределяется в производном классе, повторять ключевое слово virtual нет не­обходимости, хотя это желательно.