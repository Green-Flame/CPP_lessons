0. Существует четыре класса памяти в С:
0)Автоматический (локальные переменные). Память выделяется на стэке. Существуют только в области видимости (внутри {}), где были объявлены. Переменные, объявленные внутри функции, по умолчанию являются локальными.
1)Статический (ключевое слово static). Если static объявлен внутри функции, то переменная доступна только внутри функции, но её значение сохраняется между вызовами функции (время жизни постоянное). Если статическая переменная объявлена вне функции, то время жизни также постоянное, но эта переменная доступна в функциях того же самого файла, причем после определения переменной. .
2)Внешние переменные (ключевое слово extern). Внешние переменные доступны везде, где описаны, а не только там, где определены. Использование ключевого слова extern позволяет функции использовать внешнюю переменную, даже если она определяется позже в этом или другом файле. Переменные, описанные вне функций, по умолчанию считаются внешними.
3)Регистровые (ключевое слово register). Данные переменные хранятся в регистрах процессора. Используются для ускорения работы программы.

1. Область видимости в С большинстве случаев определяется местом объявления идентификатора. Идентификатор, объявленный вне любого определения функции является глобальным (по умолчанию относится к модулю, пакету или пространству имён, внутри которого находится его объявление). Идентификатор, объявленный внутри определения функции, является локальным в данной функции, то есть его областью видимости является эта функция. Если идентификатор является частью определения типа данных, то его область видимости совпадает с областью видимости типа, в определение которого он входит. Например,
int a = 0;  // глобальная переменная

int main()
{
    printf("%d", a); // будет выведено число 0
    {
       int a = 1; // объявлена локальная переменная а, глобальная переменная a не видна
       printf("%d", a); // будет выведено число 1
       {
          int a = 2; // еще локальная переменная в блоке, глобальная переменная a не видна, не видна и предыдущая локальная переменная
          printf("%d", a);  // будет выведено число 2
       }
    }
}

2. В С++ к перечисленным выше способам добавляется пространство имён namespace и слова public и private.

Поскольку пространства с глобальной областью видимости добавляются к системе, то имеется возможность возникновения совпадения имен. Это становится особенно актуальным при использо­вании нескольких библиотек. Использование namespace позволяет разбить глобальное пространство имен, чтобы решить подобную про­блему. По существу, namespace определяет область видимости. Общая форма namespace представлена ниже:

namespace имя {
// объявление объекта
}

Например, пусть задано пространство testNamespace:
namespace testNamespace {
	int i, k;
}

Тогда:

int main()
{
	int k = 0;
	testNamespace::k = 1;
	std::cout << k; // будет выведено 0
	std::cout << testNamespace::k; //будет выведено 1
}

3. Ключевые слова public и private нужны для управления областью видимости внутри определения классов. 
Область видимости private означает, что имя доступно только для функций своего класса. 
Область видимости public означает, что имя доступно в пределах области видимости, к которой относится его класс.
Область видимости идентификатора, объявленного внутри класса, по умолчанию является приватной.

4. Конструктор и деструктор нужны для создания и удаления объекта класса. От других методов конструктор и деструктор отличаются тем, что они не возврашают никакое значение. Конструктор может принимать аргументы (например, чтобы присвоить каким-то полям класса определённые значения), а деструктор не может принимать аргументы. Имя конструктора совпадает с именем класса, а имя деструктора - это имя класса, перед которым ставится ~.

5. Операторы new и delete нужны для выделения и освобождения динамической памяти (аналогично malloc и free в C).
Их общая форма имеет вид:

Type *ptr = new Type;

delete ptr;

Оператор new выделяет память для хранения значения типа Type и возвращает ее адрес. С помощью new могут быть размещены любые типы данных. Оператор delete освобождает память, на которую указывает указатель ptr.

6. Указатель this - это скрытый константный указатель, который содержит адрес объекта, который вызывает метод класса.
Например, пусть дан класс:

class My_class
{
private:
    int a;
 
public:
    void setNumber(int number) { a = number; }
    int getNumber() { return a; }
};

Пусть myclass1 - экземпляр класса My_class.
Тогда вызов функции myclass1.setNumber(10) на самом деле означает вызов setNumber(&myclass, 10), а само определение функции означает void setNumber(My_class* const this, int number) { this->a = number; }

Указатель this удобно использовать, например, в конструкторах, когда имена передаваемых параметров совпадают с именами полей класса:

class date
{
  int day, month, year;
public:
  date(int day, int month, int year)
  {
    this->day = day; //поле класса = аргумент
    this->month = month;
    this->year = year;
  }
};

7. std::cout и std::cin содержатся в библиотеке iostream. Для выполнения операций ввода-вывода переопределены две операции поразрядного сдвига: >>  получить из входного потока; <<  поместить в выходной поток.
std::cout используется для вывода значения в стандартный выходной поток:
 
int n = 0;
cout << n;

std::cin используется для чтения последовательности символов из входного потока:

int n;
cin >> n;

При этом из входного потока читается последовательность символов до пробела, затем эта последовательность преобразуется к типу идентификатора, и получаемое значение помещается в идентификатор.