0. Шаблон класса — это инструкции, согласно которым создаются экземпляры класса для определенного набора параметров и типов данных. Шаблоны позволяют переиспользовать код, написанный один раз, для различных типов данных. От настоящего класса шаблон отличается тем, что экземпляр класса создается только если в программе создается экземпляр класса с определёнными параметрами. 

1. Аргументами шаблона класса могут быть типы данных и нетипизированные параметры (non-type template arguments).
Например,

template <typename T, size_t NUM>
class MyClass {
private:
	T field[NUM];
};

Здесь size_t NUM является нетипизированным параметром. 
Нетипизированные параметры имеют неоторые ограничения. Нетипизированный параметр может быть целочисленного типа, перечислимого типа, ссылкой или указателем. Например, объявление double NUM недопустимо, а double *NUM допустимо. Кроме того, код шаблона не может изменять значение аргумента или использовать его адрес. Например, в данном примере выражение ++NUM недопустимо. При инициализации шаблона используемое значение должно быть константным выражением.

2. Шаблоны можно использовать рекурсивно. Например, приведенное ранее определение шаблона MyClass можно использовать так:

MyClass<MyClass<int, 100>, 200> myarray;

Здесь создается массив из 200 элементов, кождый из которых в свою очередь является массивом из 100 целых чисел. Это эквивалентно следующему объявлению:

int[200][100] myarray;

3. Допускается создание шаблонов с несколькими параметрами типа. Например, можно создать класс, содержащий два вида значений:

template <typename T0, typename T1>
class Pair {
private:
	T0 a;
	T1 b;
};

4. Можно также задать значения параметров шаблона по умолчанию. Правила использования значений по умолчанию для нетипизированных параметров такие же как у функций. Например,

template <typename T, size_t NUM = 10>
class MyClass {
private:
	T field[NUM];
};

Здесь, если не указано значение NUM, компилятор будет использовать значение 10.
В отличие от шаблонов функций, можно также указывать значения по умолчанию для параметров типа:

template <typename T = int>
class MyClass1 {
private:
	T field[10];
};

Параметры, для которых указаны значения по умолчанию, должны быть перечислены после парамтров, для которых нет значений по умолчанию.

5. Явная специализанция - это определение конкретного типа, который должен использоватся вместо общего шаблона, когда необходимо, чтобы шаблон вёл себя по-разному при создании экземпляров различных типов. Например, чтобы создавались различные методы класса для работы с различными типами данных.
Например, для приведенного ранее определения шаблона MyClass можно создать такую явную специализацию:

template <> class MyClass <double, 100> {
	// ...
};

Также можно создать неполную специализацию:

template <> class MyClass <T, 100> {
	// ...
};

При этом если при создании экземпляра шаблонного класса подходят несколько специализаций, то будет использоваться наиболее полная.

6. Оба объекта нельзя предать в функцию, т. к. функция принимает в качестве аргумента ссылку на объект класса myClass<int>, но не на объект класса myClass<double>. Объекты одного шаблонного класса, созданные с разными параметрами шаблона, являются объектами двух разных классов. 

7. В функцию можно передать только iMc100. Объекты одного шаблонного класса, созданные с разными параметрами шаблона, являются объектами двух разных классов. А аргумент функции show - это именно объект класса myClass<int, 100>, экземпляром которого является iMc100, но не iMc1000.