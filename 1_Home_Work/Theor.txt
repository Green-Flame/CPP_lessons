0. Сигнатура функции - название функции и последовательность типов передаваемых агрументов. 
Одинаковые структуры: 
	int func (int *a, int *b);
	double func (int *a, int *b);
Различные структуры:
	int func (int *a, int *b);
	int func (char *a, int *b);

1. Полиморфизм - способность одной и той же функции обрабатывать различные типы данных.

2. Перегрузка функции - возможность использовать несколько одноимённых функций. Перегружаемые функции должны иметь одинаковое имя, но разное количество или типы агрументов. Это разновидность полиморфизма, при которой вопрос о том, какую функцию вызвать, решается по списку её аргументов. Пример перегрузки функции:
	int Sqr (int a)
	{
		return (a * a);
	}

	double Sqr (double a)
	{
		return (a * a);
	}

3. Пусть задана функция для вычисления суммы трёх чисел, причём значение третьего аргумента по умолчанию равно 100:
	int Sum(int a, int b, int c = 100)
	{
		return (a + b + c);
	}

Тогда значение функции Sum(1, 2) будет равно 103 (использовано значение c по умолчанию), а значение функции Sum(1, 2, 3) будет равно 6 (значение по умолчанию не используется).

4. Шаблоны функций — это инструкции, согласно которым создаются экземпляры функции для определенного набора параметров и типов данных. Шаблоны позволяют переиспользовать код, написанный один раз, для различных типов данных. От настоящей функции шаблон отличается тем, что экземпляр функции создается только если в программе присутствует вызов функции от определённых параметров. Использование шаблонов ограничивается тем, что один и тот же шаблон не всегда подходит для всех возможных типов, с которыми он может быть конкретизирован. Например, функция, которая корректно работает при агрументах типов int, double может некорректно работать для типа char или для структур.

5. Явная специализация шаблонов - написание отдельной функции, отличающейся от шаблона, для работы с отпределёнными типами данных. Применяется для создания функций для работы с типами данных, с которыми конкретизированная по шаблону функция работает неэффективно или некорректно.
Пример: функция swap
	шаблон:
	template <typename T>
	void swap(T &a, T &b)
	{
    	T t = a;
    	a = b;
    	b = t;
    }
	явная специализация для struct section:
	struct section {
    	double start;
    	double end;
	};

	template <> void swapP<section>(section &a, section &b)
	{	
    	section t = {};
    	t.start = a.start;
    	t.end = a.end;
    	a.start = b.start;
    	a.end = b.end;
    	b.start = t.start;
    	b.end = t.end;
	}	

От обычного шаблона отличается тем, что выполняется только для определённого типа аргументов.

6. Ссылка - тип данных, являющийся скрытой формой указателя, который при использовании автоматически разименовывается. При объявлении ссылки перед её именем ставится символ амперсанда &, сама же ссылка должна быть проинициализирована именем переменной, на которую она ссылается. Тип данных, на который указывает ссылка, может быть любым, но должен совпадать с объектом, на который ссылается, то есть с типом данных ссылочной переменной. Пример объявления ссылки:
	int a = 0;
	int &c = a;

7. Ключевое слово inline нужно для объявления встроенной функции. При объявлении встроенной функции при компиляции её код копируется в программу в каждом месте, где она вызывается. Это используется для ускорения работы программы ценой занимаемой памяти.

8. Ключевое слово decltype позволяет определить тип переменной, которая будет являться результатом выражения. Например, 
	int a = 3;
	int b = 4;
	decltype(a + b) c = a + b;
Тип переменной c будет также int.
Ключевое слово auto также позволяет определить тип переменной. Например, 
	int a = 0;
	auto b = a;
Тип переменной b также будет int. auto также используется в определении функции для автоматического определения типа возвращаемого значения.